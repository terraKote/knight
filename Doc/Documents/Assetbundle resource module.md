# Assetbundle Resource Management

## Resource packaging
* ![AssetbundleBrowser after transformation](/Doc/res/images/assetbundlebrowser_improved.png)
* Transform the official AssetbundleBrowser packaging tool and replace its packaging interface with your own.
* A configuration Tab page for resource classification has been added to the tool. The resources are logically divided into different categories, and resources can be classified easily through configuration.
* In the later optimization stage of the project, you will realize the benefits of resource classification, so that different functions and resources of different modules are not related to each other. It can easily control the granularity of the resource package and reduce the dependency of the resource package.
* One problem that needs attention in resource classification is to handle the resources reused in different AB packages, and they can be classified into independent resource packages.

## Resource update
### Update download process
* During the resource update process of Unity games, resource packages will exist in three places: StreamingAssets space (resources directly included in the game package), Server space (resources used for hot updates on the server), Persitent space ( Resources downloaded from the server).
* A version file ABVersion.Bin with more information and the MD5 code of the version file, ABVersion_MD5.Bin, are regenerated for the Assetbundle package in the framework when the resource is packaged. In the ABVersion.Bin version file, the size information and version number Version information of the resource package are more than the version file generated by Unity.
* Through the above MD5 code and version number information, you can easily determine which resource packs need to be updated to the Persitent space.
* The API for downloading resources is UnityWebRequest provided by Unity.
* The resource update process is as follows:
1. Load the ABVersion_MD5.Bin file in the Persistent space.
2. Download the ABVersion_MD5.Bin file under the Server space.
3. Compare whether the MD5 codes under Persistent and Server are equal? If it is not equal, go to 4, otherwise go to 9 to exit the download process.
4. Download the ABVersion.Bin version information file under the Server space.
5. Load the ABVersion.Bin version information file in the Persistent space.
6. Compare the version information files under Server and Persistent, and record the resource package files that need to be updated in a List. (Conditions for resource packages that need to be updated: a. The version number of a single resource package on the Server is greater than the version number of a single resource package in the Persistent space. b. Only resource packages that exist on the Server)
7. Traverse the list of resource package files that need to be updated, download the resource package from the server to the Persistent space, and update the version information file ABVersion.Bin of the Persistent space after downloading a resource package.
8. After the entire download process is completed, save the version MD5 code of the Server in the Persistent space. If the terminal is downloading, it will not save the version MD5 code.
9. Finally, the version files in the Persitent space and the StreamingAssets space will be compared to finally generate the version information data object ABLoaderVersion for resource loading. (Compare the resource package path with the larger version number of a single resource package in the two spaces as the final resource package path.)
10. Complete the update download process.
### Generation of incremental update package on Server space
* Each time a resource is packaged, the incremental information of the resource package will be saved in the History of the resource package folder.
* Provides an incremental resource bundle extraction tool Tools/AssetBundle/AssetBundle History to extract all incremental resource bundles starting from a certain version.
* ![AssetbundleHistory](/Doc/res/images/assetbundle_histroy.png)

## Resource loading
* The recommended resource loading method in the framework is LZ4 + Assetbundle.LoadFromFileAsync. This loading scheme is currently the best in AssetBundle loading, which can save loading time and memory allocation to the greatest extent.
* All resource package version information is stored in the ABLoaderVersion object, which is generated through the update process.
* Coroutines are used in the framework to handle asynchronous loading of resource packs. Load the dependencies of the resource package through recursive calls.
* Cache Assetbundle object + reference count + Unload (true) method for resource loading management in the framework, this method can clearly unload a certain resource.
* Unify the underlying resource loading and unloading interfaces:
```C#
ABLoader Class
public LoaderRequest LoadAsset(string rAssetbundleName, string rAssetName, bool bIsSimulate)
public void UnloadAsset(string rAssetbundleName)
```
* Provides the use of UnityEditor.AssetDatabase.GetAssetPathsFromAssetBundleAndAssetName and UnityEditor.AssetDatabase.LoadMainAssetAtPath API in the Editor to simulate the loading of resource packs. In this way, if the resource is changed in the Editor, there is no need to rebuild the resource package to get the correct result.
* By checking Tools/Develope Mode and Tools/Simulate Mode/xxx, you can switch between simulated loading and formal loading with one click. Different resource types can have different loading modes.
* ![Assetbundle simulation mode](/Doc/res/images/assetbundle_simulate.png)